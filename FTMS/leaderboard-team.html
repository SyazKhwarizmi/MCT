<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Leaderboard - FTMS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
        }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .nav-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
        }

        .nav-btn.active {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .filter-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        label {
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }

        select {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            user-select: none;
        }

        .toggle-checkbox {
            display: none;
        }

        .toggle-slider {
            position: relative;
            width: 50px;
            height: 26px;
            background-color: #ccc;
            border-radius: 26px;
            transition: background-color 0.3s;
        }

        .toggle-slider:before {
            content: "";
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: white;
            top: 3px;
            left: 3px;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-checkbox:checked + .toggle-slider {
            background-color: #667eea;
        }

        .toggle-checkbox:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .toggle-text {
            font-weight: 600;
            color: #333;
            font-size: 1em;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-weight: 600;
            font-size: 1.2em;
        }

        .error {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            color: #c62828;
        }

        .leaderboard-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .leaderboard-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }

        .leaderboard-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .rank-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.3em;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .rank-badge.gold {
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
        }

        .rank-badge.silver {
            background: linear-gradient(135deg, #c0c0c0 0%, #808080 100%);
        }

        .rank-badge.bronze {
            background: linear-gradient(135deg, #cd7f32 0%, #8b4513 100%);
        }

        .card-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(0,0,0,0.1);
        }

        .team-name {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .team-category {
            font-size: 1em;
            color: #666;
            font-weight: 600;
        }

        .card-body {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(255,255,255,0.6);
            border-radius: 8px;
        }

        .info-label {
            font-weight: 600;
            color: #666;
        }

        .info-value {
            font-weight: bold;
            color: #333;
            font-size: 1.1em;
        }

        .largest-fish {
            font-size: 1.8em;
            color: #667eea;
            font-weight: bold;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(255,255,255,0.6);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-item-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-item-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
            grid-column: 1 / -1;
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.9;
        }
    </style>
    </head>
    <body>
    <!-- Load configuration file if available -->
    <script src="config.js" onerror="console.log('config.js not found, using localStorage instead')"></script>
    <div class="container">
        <div class="header">
            <h1>üèÜ Team Leaderboard</h1>
            <p class="subtitle">Tournament Rankings by Team</p>
        </div>

        <div class="nav-buttons">
            <a href="index.html" class="nav-btn">üìä Dashboard</a>
            <a href="leaderboard.html" class="nav-btn">üêü Submissions</a>
            <a href="leaderboard-individual.html" class="nav-btn">üë§ Individual</a>
            <a href="leaderboard-team.html" class="nav-btn active">üèÖ Team</a>
        </div>

        <div class="filter-section">
            <div class="filter-group">
                <label for="categoryAwardFilter">Filter by Category Award:</label>
                <select id="categoryAwardFilter">
                    <option value="all">All Awards</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="categoryFilter">Filter by Category:</label>
                <select id="categoryFilter">
                    <option value="all">All Categories</option>
                </select>
            </div>
            <div class="filter-group">
                <label class="toggle-label">
                    <input type="checkbox" id="videoBonusToggle" class="toggle-checkbox">
                    <span class="toggle-slider"></span>
                    <span class="toggle-text">+10 Points for Video</span>
                </label>
            </div>
        </div>

        <div id="loading" class="loading">
            Loading team leaderboard data...
        </div>

        <div id="error" class="error" style="display: none;"></div>

        <div id="leaderboardContent" style="display: none;">
            <div class="stats-summary" id="statsSummary"></div>
            <div class="leaderboard-container" id="leaderboardContainer"></div>
        </div>
    </div>

    <script>
        // Helper function to get config value (checks CONFIG first, then localStorage)
        function getConfig(key) {
            if (typeof CONFIG !== 'undefined' && CONFIG[key]) {
                return CONFIG[key];
            }
            return localStorage.getItem(key) || '';
        }

        let allSubmissions = [];
        let playersData = [];
        let teamsData = [];

        // Load data from config.js or localStorage (same config as dashboard)
        // Wait for config.js to load first
        window.addEventListener('DOMContentLoaded', function() {
            // Small delay to ensure config.js is loaded
            setTimeout(function() {
                loadLeaderboardData();
            }, 100);
        });

        async function loadLeaderboardData() {
            const loadingDiv = document.getElementById('loading');
            const errorDiv = document.getElementById('error');
            const contentDiv = document.getElementById('leaderboardContent');

            loadingDiv.style.display = 'block';
            errorDiv.style.display = 'none';
            contentDiv.style.display = 'none';

            try {
                // Get configuration from config.js first, then localStorage
                const apiKey = getConfig('apiKey');
                const sheetId = getConfig('sheetId');
                const submissionSheet = getConfig('submissionSheet') || 'submission';
                const playersSheet = getConfig('playersSheet') || 'Players';
                const teamSheet = getConfig('teamSheet') || 'Team';

                // Validate API key and Sheet ID
                if (!apiKey || !sheetId) {
                    throw new Error('API Key or Sheet ID is missing. Please check your config.js file.');
                }

                // Load all required data
                const [submissions, players, teams] = await Promise.all([
                    loadSheetData(sheetId, submissionSheet, apiKey),
                    loadSheetData(sheetId, playersSheet, apiKey),
                    loadSheetData(sheetId, teamSheet, apiKey)
                ]);

                allSubmissions = processSubmissions(submissions);
                playersData = processPlayers(players);
                teamsData = processTeams(teams);

                // Populate filter dropdown
                populateCategoryFilter();
                setupVideoBonusToggle();

                // Display leaderboard
                displayLeaderboard('all');

                loadingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
            } catch (error) {
                loadingDiv.style.display = 'none';
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Error loading data: ' + error.message;
                console.error('Error:', error);
            }
        }

        async function loadSheetData(sheetId, sheetName, apiKey) {
            if (!apiKey || !sheetId) {
                throw new Error('API Key or Sheet ID is missing');
            }

            const range = `${sheetName}!A1:Z1000`;
            const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${encodeURIComponent(range)}?key=${apiKey}`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API Error: ${response.status}`);
            }

            const data = await response.json();
            
            if (!data.values || data.values.length === 0) {
                throw new Error('No data found');
            }

            return data.values;
        }

        function processSubmissions(data) {
            if (!data || data.length < 2) return [];
            
            const headers = data[0].map(h => h.toLowerCase().replace(/\s+/g, '_'));
            const rows = data.slice(1);
            
            return rows.map(row => {
                const entry = {};
                headers.forEach((header, index) => {
                    entry[header] = row[index] || '';
                });
                // Handle both "fish_lenght" (typo) and "fish_length" (correct)
                if (!entry.fish_lenght && entry.fish_length) {
                    entry.fish_lenght = entry.fish_length;
                }
                // Handle "Release Video" - check various possible column names
                const releaseVideoNames = [
                    "release_video", "releasevideo", "video", "fish_video", 
                    "video_url", "video_link", "submission_video", "catch_video",
                    "release_video_url"
                ];
                for (let vidName of releaseVideoNames) {
                    if (entry[vidName]) {
                        entry.release_video = entry[vidName];
                        break;
                    }
                }
                return entry;
            }).filter(entry => entry.player_tag && entry.fish_type && (entry.fish_lenght || entry.fish_length));
        }

        function processPlayers(data) {
            if (!data || data.length < 2) return [];
            
            const headers = data[0].map(h => h.toLowerCase().replace(/\s+/g, '_'));
            const rows = data.slice(1);
            
            const players = {};
            rows.forEach(row => {
                const entry = {};
                headers.forEach((header, index) => {
                    entry[header] = row[index] || '';
                });
                if (entry.player_tag) {
                    players[entry.player_tag] = entry;
                }
            });
            return players;
        }

        function processTeams(data) {
            if (!data || data.length < 2) return [];
            
            const headers = data[0].map(h => h.toLowerCase().replace(/\s+/g, '_'));
            const rows = data.slice(1);
            
            // Debug: Log available columns
            console.log('Team sheet columns:', headers);
            
            const teams = {};
            rows.forEach(row => {
                const entry = {};
                headers.forEach((header, index) => {
                    entry[header] = row[index] || '';
                });
                if (entry.teamid) {
                    teams[entry.teamid] = entry;
                    // Debug: Log team data
                    console.log(`Team ${entry.teamid}:`, entry);
                }
            });
            return teams;
        }

        function calculateKingImctPoints(teamId) {
            // Get toggle state
            const videoBonusEnabled = document.getElementById('videoBonusToggle') ? document.getElementById('videoBonusToggle').checked : false;
            
            // Get team's category (boat or kayak)
            const teamInfo = teamsData[teamId] || {};
            const teamCategory = (teamInfo.category || teamInfo.category_name || teamInfo.type || '').toString().toLowerCase().trim();
            
            // Helper function to get a submission's team category
            function getSubmissionCategory(submission) {
                const player = playersData[submission.player_tag] || {};
                const playerTeamId = player.team_id || player.teamid;
                if (!playerTeamId) return '';
                const subTeamInfo = teamsData[playerTeamId] || {};
                return (subTeamInfo.category || subTeamInfo.category_name || subTeamInfo.type || '').toString().toLowerCase().trim();
            }
            
            // Helper function to get adjusted length (with video bonus if enabled)
            function getAdjustedLength(submission) {
                let length = parseFloat(submission.fish_lenght || submission.fish_length) || 0;
                if (videoBonusEnabled) {
                    const hasVideo = (submission.release_video || '').trim() !== '';
                    if (hasVideo) length += 10;
                }
                return length;
            }
            
            // Find the longest Sebarau in the same category as the team
            const allSebarau = allSubmissions
                .filter(s => {
                    if (!s.fish_type || s.fish_type.toLowerCase() !== 'sebarau') return false;
                    const subCategory = getSubmissionCategory(s);
                    return subCategory === teamCategory;
                })
                .map(s => ({
                    submission: s,
                    length: getAdjustedLength(s)
                }))
                .filter(s => s.length > 0)
                .sort((a, b) => b.length - a.length);
            
            const longestSebarau = allSebarau.length > 0 ? allSebarau[0] : null;
            
            // Find the longest Toman in the same category as the team
            const allToman = allSubmissions
                .filter(s => {
                    if (!s.fish_type || s.fish_type.toLowerCase() !== 'toman') return false;
                    const subCategory = getSubmissionCategory(s);
                    return subCategory === teamCategory;
                })
                .map(s => ({
                    submission: s,
                    length: getAdjustedLength(s)
                }))
                .filter(s => s.length > 0)
                .sort((a, b) => b.length - a.length);
            
            const longestToman = allToman.length > 0 ? allToman[0] : null;

            // Get all submissions for this team (not filtered by fish type)
            const teamSubmissions = allSubmissions.filter(submission => {
                const player = playersData[submission.player_tag] || {};
                const playerTeamId = player.team_id || player.teamid;
                return playerTeamId == teamId;
            });

            // Helper function to check if a submission matches the longest fish of its type
            function isLongestSebarau(submission) {
                if (!longestSebarau) return false;
                const sub = longestSebarau.submission;
                const subLength = getAdjustedLength(submission);
                return subLength === longestSebarau.length &&
                       submission.player_tag === sub.player_tag &&
                       (submission.fish_lenght || submission.fish_length) === (sub.fish_lenght || sub.fish_length);
            }

            function isLongestToman(submission) {
                if (!longestToman) return false;
                const sub = longestToman.submission;
                const subLength = getAdjustedLength(submission);
                return subLength === longestToman.length &&
                       submission.player_tag === sub.player_tag &&
                       (submission.fish_lenght || submission.fish_length) === (sub.fish_lenght || sub.fish_length);
            }

            // Get Sebarau submissions, excluding the longest Sebarau
            const sebarauSubmissions = teamSubmissions
                .filter(s => {
                    // First check if it's a Sebarau
                    if (!s.fish_type || s.fish_type.toLowerCase() !== 'sebarau') {
                        return false;
                    }
                    // Exclude if it's the longest Sebarau
                    return !isLongestSebarau(s);
                })
                .map(s => getAdjustedLength(s))
                .filter(length => length > 0)
                .sort((a, b) => b - a);

            // Get Toman submissions, excluding the longest Toman
            const tomanSubmissions = teamSubmissions
                .filter(s => {
                    // First check if it's a Toman
                    if (!s.fish_type || s.fish_type.toLowerCase() !== 'toman') {
                        return false;
                    }
                    // Exclude if it's the longest Toman
                    return !isLongestToman(s);
                })
                .map(s => getAdjustedLength(s))
                .filter(length => length > 0)
                .sort((a, b) => b - a);

            // Sum top 3 Sebarau + top 2 Toman
            const top3Sebarau = sebarauSubmissions.slice(0, 3).reduce((sum, length) => sum + length, 0);
            const top2Toman = tomanSubmissions.slice(0, 2).reduce((sum, length) => sum + length, 0);

            return top3Sebarau + top2Toman;
        }

        function calculateKingImctBreakdown(teamId) {
            // Get toggle state
            const videoBonusEnabled = document.getElementById('videoBonusToggle') ? document.getElementById('videoBonusToggle').checked : false;
            
            // Get team's category (boat or kayak)
            const teamInfo = teamsData[teamId] || {};
            const teamCategory = (teamInfo.category || teamInfo.category_name || teamInfo.type || '').toString().toLowerCase().trim();
            
            // Helper function to get a submission's team category
            function getSubmissionCategory(submission) {
                const player = playersData[submission.player_tag] || {};
                const playerTeamId = player.team_id || player.teamid;
                if (!playerTeamId) return '';
                const subTeamInfo = teamsData[playerTeamId] || {};
                return (subTeamInfo.category || subTeamInfo.category_name || subTeamInfo.type || '').toString().toLowerCase().trim();
            }
            
            // Helper function to get adjusted length (with video bonus if enabled)
            function getAdjustedLength(submission) {
                let length = parseFloat(submission.fish_lenght || submission.fish_length) || 0;
                if (videoBonusEnabled) {
                    const hasVideo = (submission.release_video || '').trim() !== '';
                    if (hasVideo) length += 10;
                }
                return length;
            }
            
            // Find the longest Sebarau in the same category as the team
            const allSebarau = allSubmissions
                .filter(s => {
                    if (!s.fish_type || s.fish_type.toLowerCase() !== 'sebarau') return false;
                    const subCategory = getSubmissionCategory(s);
                    return subCategory === teamCategory;
                })
                .map(s => ({
                    submission: s,
                    length: getAdjustedLength(s)
                }))
                .filter(s => s.length > 0)
                .sort((a, b) => b.length - a.length);
            
            const longestSebarau = allSebarau.length > 0 ? allSebarau[0] : null;
            
            // Find the longest Toman in the same category as the team
            const allToman = allSubmissions
                .filter(s => {
                    if (!s.fish_type || s.fish_type.toLowerCase() !== 'toman') return false;
                    const subCategory = getSubmissionCategory(s);
                    return subCategory === teamCategory;
                })
                .map(s => ({
                    submission: s,
                    length: getAdjustedLength(s)
                }))
                .filter(s => s.length > 0)
                .sort((a, b) => b.length - a.length);
            
            const longestToman = allToman.length > 0 ? allToman[0] : null;

            // Get all submissions for this team (not filtered by fish type)
            const teamSubmissions = allSubmissions.filter(submission => {
                const player = playersData[submission.player_tag] || {};
                const playerTeamId = player.team_id || player.teamid;
                return playerTeamId == teamId;
            });

            // Helper function to check if a submission matches the longest fish of its type
            function isLongestSebarau(submission) {
                if (!longestSebarau) return false;
                const sub = longestSebarau.submission;
                const subLength = getAdjustedLength(submission);
                return subLength === longestSebarau.length &&
                       submission.player_tag === sub.player_tag &&
                       (submission.fish_lenght || submission.fish_length) === (sub.fish_lenght || sub.fish_length);
            }

            function isLongestToman(submission) {
                if (!longestToman) return false;
                const sub = longestToman.submission;
                const subLength = getAdjustedLength(submission);
                return subLength === longestToman.length &&
                       submission.player_tag === sub.player_tag &&
                       (submission.fish_lenght || submission.fish_length) === (sub.fish_lenght || sub.fish_length);
            }

            // Get Sebarau submissions, excluding the longest Sebarau
            const sebarauSubmissions = teamSubmissions
                .filter(s => {
                    // First check if it's a Sebarau
                    if (!s.fish_type || s.fish_type.toLowerCase() !== 'sebarau') {
                        return false;
                    }
                    // Exclude if it's the longest Sebarau
                    return !isLongestSebarau(s);
                })
                .map(s => getAdjustedLength(s))
                .filter(length => length > 0)
                .sort((a, b) => b - a);

            // Get Toman submissions, excluding the longest Toman
            const tomanSubmissions = teamSubmissions
                .filter(s => {
                    // First check if it's a Toman
                    if (!s.fish_type || s.fish_type.toLowerCase() !== 'toman') {
                        return false;
                    }
                    // Exclude if it's the longest Toman
                    return !isLongestToman(s);
                })
                .map(s => getAdjustedLength(s))
                .filter(length => length > 0)
                .sort((a, b) => b - a);

            // Calculate totals separately
            const top3SebarauTotal = sebarauSubmissions.slice(0, 3).reduce((sum, length) => sum + length, 0);
            const top2TomanTotal = tomanSubmissions.slice(0, 2).reduce((sum, length) => sum + length, 0);

            return {
                top3SebarauTotal: top3SebarauTotal,
                top2TomanTotal: top2TomanTotal
            };
        }

        function populateCategoryFilter() {
            const categoryAwardFilter = document.getElementById('categoryAwardFilter');
            const categoryFilter = document.getElementById('categoryFilter');
            
            // Populate Category Award filter with predefined award categories
            const awardCategories = [
                'King of IMCT'
            ];
            
            categoryAwardFilter.innerHTML = '<option value="all">All Awards</option>';
            awardCategories.forEach(award => {
                const option = document.createElement('option');
                option.value = award;
                option.textContent = award;
                categoryAwardFilter.appendChild(option);
            });
            
            // Populate Category filter with all unique values from Category column in Team sheet
            const allCategories = [...new Set(
                Object.values(teamsData)
                    .map(team => {
                        // Get category from the Category column
                        const category = team.category || 
                                       team.category_name || 
                                       team.type || 
                                       team.cat ||
                                       '';
                        return category.trim();
                    })
                    .filter(cat => cat && cat !== '')
            )].sort();
            
            // Debug: Log found categories
            console.log('Categories from Team sheet:', allCategories);
            
            categoryFilter.innerHTML = '<option value="all">All Categories</option>';
            allCategories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });

            // Add event listeners
            categoryAwardFilter.addEventListener('change', function() {
                displayLeaderboard();
            });
            
            categoryFilter.addEventListener('change', function() {
                displayLeaderboard();
            });
        }

        function setupVideoBonusToggle() {
            const toggle = document.getElementById('videoBonusToggle');
            if (toggle) {
                toggle.addEventListener('change', function() {
                    displayLeaderboard();
                });
            }
        }

        function displayLeaderboard() {
            const container = document.getElementById('leaderboardContainer');
            const statsDiv = document.getElementById('statsSummary');
            
            // Get filter values
            const categoryAwardFilter = document.getElementById('categoryAwardFilter');
            const categoryFilter = document.getElementById('categoryFilter');
            const selectedAward = categoryAwardFilter ? categoryAwardFilter.value : 'all';
            const selectedCategory = categoryFilter ? categoryFilter.value : 'all';
            
            // Group submissions by team (use all submissions for point calculation)
            const teamStats = {};
            
            allSubmissions.forEach(submission => {
                const player = playersData[submission.player_tag] || {};
                const teamId = player.team_id || player.teamid || 'Unknown';
                
                if (!teamStats[teamId]) {
                    teamStats[teamId] = {
                        teamId: teamId,
                        submissions: [],
                        fishLengths: [],
                        players: new Set()
                    };
                }
                
                teamStats[teamId].submissions.push(submission);
                const fishLength = parseFloat(submission.fish_lenght) || 0;
                if (fishLength > 0) {
                    teamStats[teamId].fishLengths.push(fishLength);
                }
                if (submission.player_tag) {
                    teamStats[teamId].players.add(submission.player_tag);
                }
            });

            // Calculate team statistics
            const teamRankings = Object.values(teamStats).map(team => {
                const teamInfo = teamsData[team.teamId] || {};
                const totalSubmissions = team.submissions.length;
                const largestFish = team.fishLengths.length > 0 ? Math.max(...team.fishLengths) : 0;
                const averageLength = team.fishLengths.length > 0 
                    ? team.fishLengths.reduce((a, b) => a + b, 0) / team.fishLengths.length 
                    : 0;
                const uniquePlayers = team.players.size;

                // Get category - try different possible field names
                const category = teamInfo.category || teamInfo.category_name || teamInfo.type || 'Unknown';
                
                // Calculate points for ALL teams: top 3 Sebarau + top 2 Toman
                const teamPoints = calculateKingImctPoints(team.teamId);
                
                // Calculate breakdown for display
                const breakdown = calculateKingImctBreakdown(team.teamId);

                return {
                    teamId: team.teamId,
                    teamName: teamInfo.team_name || teamInfo.teamid || `Team ${team.teamId}`,
                    category: category,
                    totalSubmissions: totalSubmissions,
                    largestFish: largestFish,
                    averageLength: averageLength,
                    uniquePlayers: uniquePlayers,
                    teamPoints: teamPoints,
                    top3SebarauTotal: breakdown.top3SebarauTotal,
                    top2TomanTotal: breakdown.top2TomanTotal,
                    submissions: team.submissions
                };
            });

            // Sort teams: Group by category, then sort by points within category
            teamRankings.sort((a, b) => {
                const aCategory = (a.category || 'Unknown').toLowerCase();
                const bCategory = (b.category || 'Unknown').toLowerCase();
                const aIsKingOfImct = aCategory.includes('king of imct') || aCategory.includes('king imct') || aCategory.includes('kingimct');
                const bIsKingOfImct = bCategory.includes('king of imct') || bCategory.includes('king imct') || bCategory.includes('kingimct');
                
                // First, sort by category (King of IMCT first, then others alphabetically)
                if (aIsKingOfImct && !bIsKingOfImct) {
                    return -1; // King of IMCT comes first
                }
                if (!aIsKingOfImct && bIsKingOfImct) {
                    return 1; // King of IMCT comes first
                }
                
                // If same category, sort by points (descending)
                if (aCategory === bCategory || (aIsKingOfImct && bIsKingOfImct)) {
                    return b.teamPoints - a.teamPoints;
                }
                
                // Different categories: sort by category name, then by points
                const categoryCompare = aCategory.localeCompare(bCategory);
                if (categoryCompare !== 0) {
                    return categoryCompare;
                }
                
                // Same category: sort by points
                return b.teamPoints - a.teamPoints;
            });
            
            // Apply both filters
            let filteredRankings = teamRankings;
            
            // Filter by Category Award (King of IMCT)
            // King of IMCT award is based on points calculation (top 3 Sebarau + top 2 Toman)
            if (selectedAward !== 'all') {
                if (selectedAward.toLowerCase().includes('king of imct') || 
                    selectedAward.toLowerCase().includes('king imct')) {
                    // Show teams that have points (top 3 Sebarau + top 2 Toman > 0)
                    filteredRankings = filteredRankings.filter(team => {
                        return team.teamPoints > 0;
                    });
                } else {
                    // For other awards, match by category name
                    filteredRankings = filteredRankings.filter(team => {
                        const teamCategory = (team.category || 'Unknown').toLowerCase();
                        const awardLower = selectedAward.toLowerCase();
                        return teamCategory.includes(awardLower) || 
                               awardLower.includes(teamCategory) ||
                               teamCategory === awardLower;
                    });
                }
            }
            
            // Filter by Category (from Category column in Team sheet)
            if (selectedCategory !== 'all') {
                filteredRankings = filteredRankings.filter(team => {
                    const teamCategory = (team.category || 'Unknown').toLowerCase();
                    const filterCategory = selectedCategory.toLowerCase();
                    return teamCategory === filterCategory;
                });
            }
            
            // Debug: Log sorted teams
            console.log('Sorted team rankings:', filteredRankings.map(t => ({
                team: t.teamName,
                category: t.category,
                points: t.teamPoints,
                largestFish: t.largestFish
            })));

            // Clear container
            container.innerHTML = '';

            if (filteredRankings.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üèÖ</div>
                        <h3>No team data found</h3>
                        <p>No data available for the selected filter.</p>
                    </div>
                `;
                statsDiv.innerHTML = '';
                return;
            }

            // Display statistics
            const totalTeams = filteredRankings.length;
            const totalSubmissions = filteredRankings.reduce((sum, team) => sum + team.totalSubmissions, 0);
            const totalPlayers = new Set(
                filteredRankings.flatMap(team => 
                    team.submissions.map(s => s.player_tag).filter(Boolean)
                )
            ).size;
            const highestPoints = filteredRankings.length > 0 ? filteredRankings[0].teamPoints : 0;

            statsDiv.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${totalTeams}</div>
                    <div class="stat-label">Total Teams</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${totalSubmissions}</div>
                    <div class="stat-label">Total Submissions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${totalPlayers}</div>
                    <div class="stat-label">Total Players</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${highestPoints.toFixed(1)}</div>
                    <div class="stat-label">Highest Points</div>
                </div>
            `;

            // Create cards
            filteredRankings.forEach((team, index) => {
                const rank = index + 1;
                const card = createTeamCard(team, rank);
                container.appendChild(card);
            });
        }

        function createTeamCard(team, rank) {
            const card = document.createElement('div');
            card.className = 'leaderboard-card';
            
            const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
            
            // Display points for all teams (Top 3 Sebarau + Top 2 Toman)
            const pointsDisplay = `
                <div class="info-row" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-weight: bold;">
                    <span class="info-label" style="color: white;">Team Points:</span>
                    <span class="largest-fish" style="color: white; font-size: 2em;">${team.teamPoints.toFixed(1)}</span>
                </div>
            `;
            
            card.innerHTML = `
                <div class="rank-badge ${rankClass}">#${rank}</div>
                <div class="card-header">
                    <div class="team-name">${team.teamName}</div>
                    <div class="team-category">${team.category}</div>
                </div>
                <div class="card-body">
                    ${pointsDisplay}
                    <div class="info-row">
                        <span class="info-label">Top 3 Sebarau Total:</span>
                        <span class="largest-fish">${team.top3SebarauTotal.toFixed(1)} cm</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Top 2 Toman Total:</span>
                        <span class="largest-fish">${team.top2TomanTotal.toFixed(1)} cm</span>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-item-value">${team.totalSubmissions}</div>
                            <div class="stat-item-label">Submissions</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-item-value">${team.uniquePlayers}</div>
                            <div class="stat-item-label">Players</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-item-value" style="font-size: 0.9em; word-break: break-word;">${team.teamName}</div>
                            <div class="stat-item-label">Team Name</div>
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }
    </script>
</body>
</html>

